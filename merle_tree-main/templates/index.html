<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Merkle Tree Construction and Verification</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
 <style>
/* üåü GLOBAL THEME ‚Äî clean professional block layout */
body {
  font-family: 'Poppins', sans-serif;
  background: #f5f8ff; /* light soft background */
  color: #111;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

/* üåü HEADER */
header {
  text-align: center;
  background: linear-gradient(90deg, #004aad, #0078ff);
  color: white;
  padding: 30px 20px;
  border-bottom-left-radius: 25px;
  border-bottom-right-radius: 25px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

header h1 {
  margin: 0;
  font-size: 2.2rem;
  letter-spacing: 0.5px;
}

nav {
  margin-top: 15px;
}

nav button {
  background: #ffffff33;
  border: none;
  color: white;
  padding: 10px 18px;
  margin: 5px;
  border-radius: 25px;
  font-weight: 600;
  cursor: pointer;
  transition: 0.3s;
  backdrop-filter: blur(6px);
}

nav button:hover {
  background: white;
  color: #004aad;
  transform: translateY(-2px);
}

nav button.active-tab {
  background: white;
  color: #004aad;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
}

/* üåü MAIN LAYOUT */
main {
  flex: 1;
  padding: 40px 25px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Each Section looks like a block */
.content-section {
  display: none;
  width: 100%;
  max-width: 1100px;
}

.content-section.active {
  display: block;
  animation: fadeIn 0.6s ease-in-out;
}

/* üåü BLOCK CARDS */
.card {
  background: #fff;
  border-radius: 16px;
  padding: 35px 40px;
  margin: 25px 0;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
  border: 1px solid #e0e8ff;
  transition: 0.3s;
}

.card:hover {
  transform: translateY(-4px);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
}

h2 {
  color: #004aad;
  font-weight: 700;
  font-size: 1.6rem;
  margin-bottom: 15px;
  border-left: 5px solid #0078ff;
  padding-left: 10px;
}

h3 {
  color: #005fcc;
  margin-top: 20px;
  margin-bottom: 10px;
}

p, li {
  font-size: 15.5px;
  line-height: 1.8;
  color: #222;
}

ul, ol {
  padding-left: 25px;
}

@keyframes fadeIn {
  from {opacity: 0; transform: translateY(10px);}
  to {opacity: 1; transform: translateY(0);}
}

/* üåü SIMULATION BOX */
.simulation-box {
  margin-top: 20px;
}

.simulation-box .row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.simulation-box input {
  padding: 10px;
  border-radius: 8px;
  border: 1px solid #aac6e8;
  font-size: 15px;
  background: #f8faff;
  color: #111;
  flex: 1;
}

.simulation-box button {
  background: linear-gradient(90deg, #0078ff, #00b3ff);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 10px 18px;
  cursor: pointer;
  font-weight: 600;
  transition: 0.3s;
}

.simulation-box button:hover {
  background: linear-gradient(90deg, #005ed1, #0099e6);
  transform: scale(1.05);
}

/* üå≥ MERKLE TREE VISUAL */
.tree-level {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 15px;
  margin: 18px 0;
}

.tree-node {
  min-width: 90px;
  padding: 10px;
  text-align: center;
  font-family: monospace;
  border-radius: 10px;
  border: 2px solid #ccc;
  background: #ffffff;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
}

.tree-root {
  background: linear-gradient(180deg, #0078ff, #005fcc);
  color: white;
  border-color: #004aad;
}

.leaf-node {
  background: linear-gradient(180deg, #e9f6ff, #cdeaff);
  border-color: #0288d1;
}

.tampered {
  background: linear-gradient(180deg, #f8d7da, #f1b0b8)!important;
  border-color: #dc3545!important;
  color: #721c24!important;
}

.verified {
  background: linear-gradient(180deg, #d4edda, #b7e3bf)!important;
  border-color: #28a745!important;
  color: #155724!important;
}

/* üåü CODE PAGE */
#code .card {
  background: #fff;
  border-radius: 18px;
  padding: 30px 35px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.07);
  border: 1px solid #dfe7ff;
}

#code h2 {
  color: #004aad;
  border-left: 5px solid #0078ff;
  padding-left: 10px;
  margin-bottom: 20px;
}

#code pre {
  background: #f8f9fb;
  color: #111;
  padding: 18px 22px;
  border-radius: 10px;
  border-left: 6px solid #0078ff;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 15px;
  font-weight: 600;
  overflow-x: auto;
  margin-top: 15px;
  user-select: text;
}

#code code {
  background: #f0f0f0;
  padding: 3px 6px;
  border-radius: 4px;
  color: #000;
  font-weight: 700;
}

.example-box {
  background: #f2f8ff;
  border-left: 4px solid #007bff;
  padding: 8px 12px;
  margin: 6px 0 12px 0;
  border-radius: 8px;
  font-size: 15px;
  color: #333;
}

/* üåü FOOTER */
footer {
  text-align: center;
  background: #004aad;
  color: white;
  padding: 20px;
  font-weight: 600;
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  margin-top: 20px;
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
}

/* üåü RESPONSIVE */
@media (max-width: 768px) {
  .card {
    padding: 25px 20px;
  }
  header h1 {
    font-size: 1.6rem;
  }
}
</style>
</head>

<body>
  <header>
    <h1>Merkle Tree Construction and Verification</h1>
    <nav>
      <button class="active-tab">Aim</button>
      <button>Theory</button>
      <button>Procedure</button>
      <button>Code</button>
      <button>Simulation</button>
      <button>Conclusion</button>
    </nav>
  </header>

  <main>
    <!-- AIM -->
    <section class="content-section active">
  <div class="card">
    <h2>üéØ Aim</h2>
    <p>The aim of this experiment is to build and verify a <b>Merkle Tree</b> to check if data has been changed or tampered, using <b>SHA-256 hashing</b> for security.</p>

    <h3>‚úÖ Objectives</h3>
    <ul>
      <li>To create a Merkle Tree from given data blocks.</li>
      <li>To calculate the Merkle Root that represents all data securely.</li>
      <li>To verify if a specific data block is part of the tree.</li>
      <li>To detect data tampering by checking changes in the root hash.</li>
      <li>To understand how Merkle Trees help keep data safe in blockchain systems.</li>
    </ul>
  </div>
</section>


    <!-- THEORY -->
    <section class="content-section">
  <div class="card">
    <h2>üìò Theory</h2>

<p>
  A <b>Merkle Tree</b> is a special data structure used to check if data is correct and has not been changed.  
  Each <b>leaf node</b> stores the <b>hash</b> of a data block, and each <b>parent node</b> stores the hash of its two child nodes combined.  
  The final hash at the top is called the <b>Merkle Root</b>, which represents all data in the tree.
</p>

<h3>üîπ What is Hashing?</h3>
<p>
  <b>Hashing</b> is the process of converting any input data (like text, a file, or a number) into a fixed-length unique code called a <b>hash value</b>.  
  This conversion is done using a special mathematical function known as a <b>hash function</b>.
</p>

<div class="example-box">
  <b>Formula:</b>  
  <pre><code>Hash Value (H) = Hash_Function(Input Data)</code></pre>
</div>

<p>
  In simple terms, the hash function takes some input data ‚Äî like <b>"Hello"</b> ‚Äî and produces a unique hash value such as:
</p>

<div class="example-box">
  Example:  
  <code>H("Hello") = 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969</code>  
</div>
<p>
  üîç <b>Explanation of Formula:</b><br>
  The hash function applies mathematical and logical operations on the input data to create a fixed-size result (usually a long combination of letters and numbers).  
  - It always gives the <b>same output</b> for the same input.  
  - Even if you change one letter (like ‚ÄúHello‚Äù ‚Üí ‚Äúhello‚Äù), the output hash becomes <b>completely different</b>.  
  - That‚Äôs why hashing helps in verifying if data has been <b>changed or tampered with</b>.
</p>

<h3>üîπ How Hashing Happens in Merkle Tree</h3>
<p>
  Each data block (for example, A, B, C, D) is passed through a hash function to generate its unique hash.  
  These hashed values form the <b>leaf nodes</b> of the Merkle Tree.  
  Then, pairs of these hashes are combined and hashed again to form <b>parent nodes</b>.  
  This process continues until a single final hash ‚Äî the <b>Merkle Root</b> ‚Äî is obtained.
</p>

<h3>üîπ Algorithm Used: SHA-256</h3>
<p>
  The <b>SHA-256 (Secure Hash Algorithm 256-bit)</b> is used for hashing in Merkle Trees.  
  It is part of the SHA-2 family developed by the <b>National Security Agency (NSA)</b>.  
  This algorithm produces a 256-bit (64-character) hash value.  
  It is widely used in <b>blockchain systems</b> because it is:
</p>
<ul>
  <li><b>Secure:</b> It is almost impossible to reverse or find two inputs with the same hash.</li>
  <li><b>Consistent:</b> The same input always gives the same output.</li>
  <li><b>Fast:</b> Can process large amounts of data efficiently.</li>
  <li><b>Tamper-proof:</b> Any change in input data causes a totally different hash.</li>
</ul>

<h3>üîπ Summary</h3>
<p>
  In a Merkle Tree, <b>SHA-256 hashing</b> ensures that every block of data is represented securely.  
  The <b>Merkle Root</b> acts like a digital fingerprint for the entire dataset ‚Äî if any data changes, the root hash changes, helping detect data tampering quickly.
</p>
    <h3>üí° Features</h3>
    <ul>
      <li>Allows <b>quick verification</b> of any data block without checking the full dataset.</li>
      <li>Any <b>change in data</b> automatically changes the <b>Merkle Root</b>.</li>
      <li>Uses <b>SHA-256 hashing</b> for strong security.</li>
      <li>Ensures <b>tamper detection</b> and <b>data integrity</b> like in blockchain systems.</li>
    </ul>

    <h3>üîß Applications</h3>
    <ul>
      <li><b>Blockchain:</b> Verify transactions securely and efficiently.</li>
      <li><b>Cloud Storage:</b> Check file integrity using Merkle proofs.</li>
      <li><b>Git:</b> Track and verify commits using hash-based trees.</li>
      <li><b>Security Systems:</b> Detect <b>data tampering</b> or unauthorized changes quickly.</li>
    </ul>
  </div>
</section>

    <!-- PROCEDURE -->
    <section class="content-section">
  <div class="card">
    <h2>üß© Procedure</h2>
    <ol>
      <li>
        <b>Enter data values:</b>  
        Start by entering a set of values as leaves in the input box.
        <div class="example-box"><b>Example:</b> A B C D</div>
      </li>

      <li>
        <b>Hash each leaf:</b>  
        Each data value is converted into its SHA-256 hash.
        <div class="example-box"><b>Example:</b> hash(A), hash(B), hash(C), hash(D)</div>
      </li>

      <li>
        <b>Combine and hash pairs:</b>  
        Pair the leaf hashes and hash them again to form the next level of the tree.
        <div class="example-box"><b>Example:</b> hash(AB) = hash(hash(A) + hash(B))</div>
      </li>

      <li>
        <b>Repeat the process:</b>  
        Keep combining and hashing pairs until only one hash remains.
        <div class="example-box"><b>Example:</b> Root = hash(hash(AB) + hash(CD))</div>
      </li>

      <li>
        <b>Verify a leaf:</b>  
        Select a data value (like A) and rebuild its path up to the root.
        <div class="example-box"><b>Example:</b> hash(A) ‚Üí hash(AB) ‚Üí Root</div>
      </li>

      <li>
        <b>Compare roots:</b>  
        Compare the newly computed root with the stored Merkle Root.
        <div class="example-box"><b>Example:</b> Both roots match ‚Üí Data is valid ‚úÖ</div>
      </li>

      <li>
        <b>Test tampering:</b>  
        Change one leaf value (like A ‚Üí X) and rebuild the tree.  
        The new root will not match the original root.
        <div class="example-box"><b>Example:</b> Root changed ‚Üí Data was tampered ‚ùå</div>
      </li>
    </ol>
  </div>
</section>


    <!-- CODE -->
<section id="code" class="content-section">
  <div class="card">
    <h2>üíª Code Implementation</h2>
    <p>This web-based Merkle Tree Lab uses <b>Flask (Python)</b> as the backend to build and verify trees, and <b>JavaScript</b> for frontend visualization.</p>
    
    <h3>üìÇ <code>app.py</code></h3>
    <p>This file runs the Flask web server and connects the web page to backend logic. It defines API routes to:</p>
    <ul>
      <li>Generate the Merkle Tree from given leaves</li>
      <li>Provide Merkle Proofs for verification</li>
      <li>Verify proofs against a Merkle Root</li>
    </ul>

<pre><code class="language-python">
# app.py
from flask import Flask, render_template, request, jsonify
from tree import build_merkle_tree, get_proof, verify_proof
from typing import List

app = Flask(__name__, static_folder="static", template_folder="templates")

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/generate', methods=['POST'])
def api_generate():
    payload = request.get_json() or {}
    data: List[str] = payload.get('data', [])
    if not isinstance(data, list):
        return jsonify({"error": "data must be a list of strings"}), 400
    levels = build_merkle_tree(data)
    root = levels[-1][0] if levels and levels[-1] else ""
    return jsonify({"levels": levels, "root": root})

@app.route('/api/proof', methods=['POST'])
def api_proof():
    payload = request.get_json() or {}
    data: List[str] = payload.get('data', [])
    value = payload.get('value', "")
    if value not in data:
        return jsonify({"error": "Value not found in leaves"}), 400
    idx = data.index(value)
    proof, root = get_proof(data, idx)
    return jsonify({"proof": proof, "root": root})

@app.route('/api/verify', methods=['POST'])
def api_verify():
    payload = request.get_json() or {}
    value = payload.get('value', "")
    proof = payload.get('proof', [])
    root = payload.get('root', "")
    ok = verify_proof(value, proof, root)
    return jsonify({"result": ok})

if __name__ == '__main__':
    app.run(debug=True, port=5006)
</code></pre>

    <h3>üß† <code>tree.py</code></h3>
    <p>This file contains the <b>Merkle Tree logic</b> ‚Äî all the hashing, proof generation, and verification algorithms used by the backend.</p>
    <ul>
      <li><b>sha256(x)</b> ‚Äî computes SHA-256 hash</li>
      <li><b>build_merkle_tree(leaves)</b> ‚Äî builds the entire tree bottom-up</li>
      <li><b>get_proof(leaves, index)</b> ‚Äî generates a proof for a leaf</li>
      <li><b>verify_proof(leaf, proof, root)</b> ‚Äî validates proof against root</li>
    </ul>

<pre><code class="language-python">
# tree.py
import hashlib
from typing import List, Dict, Tuple

def sha256(x: str) -> str:
    """Return SHA-256 hash of a string."""
    return hashlib.sha256(x.encode('utf-8')).hexdigest()

def build_merkle_tree(leaves: List[str]) -> List[List[str]]:
    """Builds Merkle tree levels from leaves to root."""
    if not leaves:
        return [[]]

    level = [sha256(str(l)) for l in leaves]
    tree = [level]

    while len(level) > 1:
        new_level = []
        for i in range(0, len(level), 2):
            left = level[i]
            right = level[i+1] if i+1 < len(level) else left
            new_level.append(sha256(left + right))
        level = new_level
        tree.append(level)
    return tree

def get_proof(leaves: List[str], index: int) -> Tuple[List[Dict], str]:
    """Generate proof for a leaf at given index."""
    tree = build_merkle_tree(leaves)
    proof = []
    idx = index
    for lvl in range(len(tree)-1):
        layer = tree[lvl]
        is_right = idx % 2 == 1
        sibling_index = idx - 1 if is_right else idx + 1
        position = "left" if is_right else "right"

        if sibling_index < len(layer):
            proof.append({"position": position, "hash": layer[sibling_index]})
        idx //= 2
    root = tree[-1][0] if tree else ""
    return proof, root

def verify_proof(leaf: str, proof: List[Dict], root: str) -> bool:
    """Verify that leaf + proof reconstructs the root."""
    computed = sha256(str(leaf))
    for p in proof:
        sibling = p.get("hash", "")
        if p.get("position") == "left":
            computed = sha256(sibling + computed)
        else:
            computed = sha256(computed + sibling)
    return computed == root
</code></pre>

    <h3>üß© Why These Files Are Used</h3>
    <ul>
      <li><b>app.py</b> ‚Äî acts as the <b>backend controller</b> for the Flask web app. It connects the webpage to the Merkle Tree logic via REST APIs.</li>
      <li><b>tree.py</b> ‚Äî contains the <b>core Merkle Tree algorithms</b> (hashing, proof creation, verification).</li>
      <li>The <b>index.html</b> frontend interacts with these Flask routes using JavaScript or AJAX calls, creating a full end-to-end simulation of Merkle Tree behavior.</li>
    </ul>
  </div>
</section>
    <!-- SIMULATION -->
    <section class="content-section">
      <div class="card simulation-box">
        <h2>‚öôÔ∏è Simulation</h2>
        <div class="row">
          <label>Enter leaves:</label>
          <input id="leavesInput" placeholder="e.g. A B C D" />
          <button id="buildBtn">Build Tree</button>
        </div>

        <div class="row">
          <label>Verify leaf:</label>
          <input id="verifyLeafInput" placeholder="Enter leaf (e.g. A)" />
          <button id="verifyBtn">Verify</button>
        </div>

        <hr>

        <div class="row">
          <label>Index to tamper:</label>
          <input type="number" id="tamperIndex" min="0" style="width:70px;">
          <label>New value:</label>
          <input type="text" id="tamperValue" style="width:120px;">
          <button id="tamperBtn">Tamper</button>
          <button id="resetBtn">Reset</button>
        </div>

        <div id="output"></div>
        <div id="verifyOutput"></div>
      </div>
    </section>

    <!-- CONCLUSION -->
    <section class="content-section">
  <div class="card">
    <h2>üîö Conclusion</h2>
    <ul>
      <li>We built and visualized a Merkle Tree from user-entered data.</li>
      <li>The simulation showed how each data block is converted into hashes and combined to form the Merkle Root.</li>
      <li>We verified individual leaves using Merkle proofs.</li>
      <li>We demonstrated how tampering a single leaf changes the Merkle Root.</li>
      <li>This proved that Merkle Trees can quickly detect any data modification.</li>
      <li>The lab helped understand how data verification works in blockchains and secure systems.</li>
    </ul>
  </div>
</section>
  </main>

  <footer>¬© 2025 Merkle Tree Virtual Lab </footer>

  <script>
    $(document).ready(function() {
      async function sha256(str) {
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        const hash = await crypto.subtle.digest('SHA-256', data);
        return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
      }

      async function buildMerkleTree(leaves) {
        let tree = [];
        let level = await Promise.all(leaves.map(sha256));
        tree.push(level);
        while (level.length > 1) {
          let next = [];
          for (let i = 0; i < level.length; i += 2) {
            const left = level[i];
            const right = level[i + 1] || left;
            next.push(await sha256(left + right));
          }
          tree.push(next);
          level = next;
        }
        return tree;
      }

      function displayTree(tree, leaves) {
        let html = '<h3>Merkle Tree Structure:</h3>';
        for (let i = tree.length - 1; i >= 0; i--) {
          html += '<div class="tree-level">';
          for (let j = 0; j < tree[i].length; j++) {
            const cls = i === 0 ? 'tree-node leaf-node' : (i === tree.length - 1 ? 'tree-node tree-root' : 'tree-node');
            const label = i === 0 ? leaves[j] : tree[i][j].substring(0,8);
            html += `<div class="${cls}" id="node-${i}-${j}">${label}</div>`;
          }
          html += '</div>';
        }
        return html;
      }

      let globalTree = [], globalLeaves = [], trustedRoot = '', originalLeaves = [];

      $('#buildBtn').click(async () => {
        const input = $('#leavesInput').val().trim();
        if (!input) return alert('Enter some leaves!');
        globalLeaves = input.split(/\s+/);
        globalTree = await buildMerkleTree(globalLeaves);
        trustedRoot = globalTree[globalTree.length - 1][0];
        originalLeaves = [...globalLeaves];
        $('#output').html(displayTree(globalTree, globalLeaves) + `<p><b>Trusted Root:</b> ${trustedRoot}</p>`);
      });

      $('#verifyBtn').click(async () => {
        const leaf = $('#verifyLeafInput').val().trim();
        if (!leaf) return alert('Enter leaf!');
        const idx = globalLeaves.indexOf(leaf);
        if (idx === -1) return $('#verifyOutput').html('<p style="color:red;">Leaf not found ‚ùå</p>');
        const tree = await buildMerkleTree(globalLeaves);
        const root = tree[tree.length - 1][0];
        const verified = root === trustedRoot;
        $(`#node-0-${idx}`).toggleClass('verified', verified).toggleClass('tampered', !verified);
        $('#verifyOutput').html(`<p>Verification of "<b>${leaf}</b>": ${verified ? '<b style="color:green;">‚úÖ Verified</b>' : '<b style="color:red;">‚ùå Tampered</b>'}</p>`);
      });

      $('#tamperBtn').click(async () => {
        const idx = parseInt($('#tamperIndex').val());
        const val = $('#tamperValue').val().trim();
        if (isNaN(idx) || !val || idx >= globalLeaves.length) return alert('Enter valid tamper details!');
        globalLeaves[idx] = val;
        const tree = await buildMerkleTree(globalLeaves);
        const newRoot = tree[tree.length - 1][0];
        const tampered = newRoot !== trustedRoot;
        $('#output').html(displayTree(tree, globalLeaves) + `<p><b>Trusted Root:</b> ${trustedRoot}</p><p><b>New Root:</b> ${newRoot}</p><p>${tampered ? '‚ùå Tampering detected' : '‚úÖ No tampering'}</p>`);
      });

      $('#resetBtn').click(async () => {
        globalLeaves = [...originalLeaves];
        globalTree = await buildMerkleTree(globalLeaves);
        trustedRoot = globalTree[globalTree.length - 1][0];
        $('#output').html(displayTree(globalTree, globalLeaves) + `<p><b>Trusted Root:</b> ${trustedRoot}</p>`);
        $('#verifyOutput').html('');
      });

      // Tab switching
      const tabs = document.querySelectorAll('nav button');
      const sections = document.querySelectorAll('.content-section');
      tabs.forEach((tab, i) => tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active-tab'));
        tab.classList.add('active-tab');
        sections.forEach(s => s.classList.remove('active'));
        sections[i].classList.add('active');
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }));
    });
  </script>
</body>
</html>

